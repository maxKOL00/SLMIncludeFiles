#pragma once

#include <vector> // vector
#include <random> // default_random_engine, uniform_int_distribution
#include <algorithm> // generate, transform
#include <iostream> // cout
#include <iomanip> // setw, setfill
#include <stdexcept>

#include "statusBox.h"

#include "Parameters.h"
#include "TweezerArray.h"
#include "basic_fileIO.h"
#include "math_utils.cuh"
#include "cuda_utils.cuh"

class CGHAlgorithm {
    public:
        // Initialize parameters taken from config
        // Allocates memory for the slm-plane and the image-plane arrays
        // Generates the beam amplitude array from the waists given in the config
        explicit CGHAlgorithm(
            const Parameters& params, statusBox *box
        );
        // Free all the cuda stuff. This is usually handled quite smoothly even without calling the
        // destructor but the Vimba API doesn't like to be terminated abruptly
        ~CGHAlgorithm(
            void
        ) noexcept;

        // Main 2D adaptive weighted Gerchberg-Saxton algorithm
        std::vector<double> AWGS2D_loop(
            TweezerArray& tweezer_array,
            byte* phasemap_out
        );

        // Main 3D adaptice weighted Gerchberg-Saxton algorithm
        // Returns the non-uniformity vector
        std::vector<double> AWGS3D_loop(
            std::vector<TweezerArray>& tweezer_array3D,
            double layer_separation_um,
            byte* phasemap_out
        );

        // Single awgs iteration.
        // Returns the non-uniformity
        double AWGS2D_camera_feedback_iteration(
            TweezerArray& tweezer_array,
            const byte* camera_image,
            byte* phasemap_out
        );

        // FileIO. These could be moved into basic_fileIO but for debugging
        // this is easier as they know all the member variables

        // [[maybe_unused]]; in c++ 17
        void save_input_intensity_distribution(
            const std::string& filename
        ) const;

        void save_input_phase_distribution(
            const std::string& filename
        ) const;

        void save_output_intensity_distribution(
            const std::string& filename, TweezerArray tweezer_array
        ) const;

        void save_output_intensity_distribution_max(
            const std::string& filename, TweezerArray tweezer_array
        ) const;

    private:
        // Be careful if you change this order as the initializer list depends on
        // the order of initialization

        // General parameters
    const double slm_pixel_size_mm;

    // Unpadded dimension and the related delta_k

    const double focal_length_px;
    const double wavelength_px;

    const size_t max_iterations;
    const size_t fixed_phase_limit_iterations;
    const double fixed_phase_limit_nonuniformity;
    const double max_nonuniformity;

    const double weighting_parameter;

    const int random_seed;

    const unsigned int number_of_pixels_padded;
    const unsigned int number_of_pixels_unpadded;
    const unsigned int block_size;
    const unsigned int num_blocks_padded;
    const unsigned int first_nonzero_index;


    // FFT and main adaptive WGS-loop related vars
    cufftHandle fft_plan;
    double* beam_amplitudes;
    cufftDoubleComplex* slm_plane, * image_plane;

    statusBox* editA;
    // Allocate arrays in shared memory and set up fft plan
    void init_cuda(
        void
    );

    void generate_beam_amplitude_array(
        double sigma_x_mm, double sigma_y_mm
    ) noexcept;

    // Calculate the weights which are used to correct the target amplitude for every
    // tweezer site. I feel like this is part of the algorithm and not of the
    // tweezerarray class
    // Can be noexcept because intensities will be resized just before it is passed to
    // get_intensities()
    std::vector<double> calculate_weights(
        const std::vector<double>& values, double mean
    ) const noexcept;


    // Sets the initial phasemap to either 1) random in the beginning of the loop
    // or 2) by the previously computed phasemap for the camera feedback
    void set_initial_phase_distribution(
        const byte* initial_guess
    ) noexcept;

    // The phases are generated by the random library using a MT-PRNG.
    std::vector<byte> generate_random_phase_distribution(
        int seed
    ) const noexcept;
};
